Index: Optimizer.Logic/Work/Heuristics/GeneralPeopleHeuristic.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace Optimizer.Logic.Work.Heuristics;\r\n\r\ninternal static class GeneralPeopleHeuristic\r\n{\r\n    public const int MinPerfectAssignmentsPerDayCount = 6;\r\n    public const int MaxPerfectAssignmentsPerDayCount = 10;\r\n    public const int AcceptableMaxAssignmentsInBlockPerDay = 9;\r\n    public const int AcceptableMaxAssignmentSpreadPerDay = 10;\r\n\r\n    internal static float CalculateScore(PartialSolution solution)\r\n    {\r\n        var operation = new Operation(solution);\r\n        operation.Work();\r\n        return operation.CalculateScore();\r\n    }\r\n\r\n    private class Operation\r\n    {\r\n        // TODO3: Żeby obrony zaczynały się od rana (czyli mozna liczyc ile jest dziury rano mają mniejsze penalty, niż dziury wieczorem), użycie kolejnego dnia obron powinno być również penalty\r\n        // TODO4: Plusik za wypełnienie promotora_recenzenta i supervisora\r\n\r\n        private struct PersonAssignmentBlock\r\n        {\r\n            public int StartIndex;\r\n            public int EndIndex;\r\n            public int ClassroomIndex;\r\n        }\r\n\r\n        private struct PersonPerDayMemory\r\n        {\r\n            public int? FirstAssignment;\r\n            public int? LastAssignment;\r\n            public readonly List<PersonAssignmentBlock> AssignmentBlocks;\r\n            public int TotalAssignments;\r\n\r\n            public PersonPerDayMemory()\r\n            {\r\n                FirstAssignment = null;\r\n                LastAssignment = null;\r\n                AssignmentBlocks = new List<PersonAssignmentBlock>();\r\n                TotalAssignments = 0;\r\n            }\r\n        }\r\n\r\n        private struct PersonMemory\r\n        {\r\n            public readonly PersonPerDayMemory[] Days;\r\n            public int TotalAssignments;\r\n            public readonly bool Exists;\r\n\r\n            public PersonMemory(int days)\r\n            {\r\n                Exists = true;\r\n                TotalAssignments = 0;\r\n                Days = new PersonPerDayMemory[days];\r\n                for (int i = 0; i < days; i++)\r\n                    Days[i] = new PersonPerDayMemory();\r\n            }\r\n        }\r\n\r\n        private struct DayMemory\r\n        {\r\n            public int? FirstAssignment;\r\n            public int? LastAssignment;\r\n            public int TotalAssignmentsFilled;\r\n        }\r\n\r\n        private readonly PersonMemory[] _peopleMemory;\r\n        private readonly DayMemory[] _daysMemory;\r\n        private readonly PartialSolution _solution;\r\n\r\n        public Operation(PartialSolution solution)\r\n        {\r\n            _peopleMemory = new PersonMemory[byte.MaxValue+1];\r\n            var daysInPartialSolution = solution.Days.Length;\r\n            _daysMemory = new DayMemory[daysInPartialSolution];\r\n            \r\n            for (var i = 0; i < solution.PeopleIds.Count; i++)\r\n            {\r\n                _peopleMemory[solution.PeopleIds[i]] = new PersonMemory(daysInPartialSolution);\r\n            }\r\n\r\n            _solution = solution;\r\n        }\r\n        \r\n        public void Work()\r\n        {\r\n            for (var dIndex = 0; dIndex < _solution.Days.Length; dIndex++)\r\n            {\r\n                var solutionDay = _solution.Days[dIndex];\r\n                for (var aIndex = 0; aIndex < solutionDay.SlotCount; aIndex++)\r\n                {\r\n\r\n                    for (int cIndex = 0; cIndex < solutionDay.Classrooms.Length; cIndex++)\r\n                    {\r\n                        // chronologically\r\n                        var assignment = solutionDay.Classrooms[cIndex].Assignments[aIndex];\r\n\r\n                        void WorkForPerson(int personId)\r\n                        {\r\n                            var memory = _peopleMemory[personId];\r\n                            _peopleMemory[personId].TotalAssignments++;\r\n                            memory.Days[dIndex].FirstAssignment ??= aIndex;\r\n                            memory.Days[dIndex].LastAssignment = aIndex;\r\n                            if (memory.Days[dIndex].AssignmentBlocks.Count == 0)\r\n                            {\r\n                                memory.Days[dIndex].AssignmentBlocks.Add(new PersonAssignmentBlock()\r\n                                {\r\n                                    ClassroomIndex = cIndex,\r\n                                    StartIndex = aIndex,\r\n                                    EndIndex = aIndex\r\n                                });\r\n                            }\r\n                            else\r\n                            {\r\n                                var lastBlockIndex = memory.Days[dIndex].AssignmentBlocks.Count - 1;\r\n                                var lastAssignmentBlock = memory.Days[dIndex].AssignmentBlocks[lastBlockIndex];\r\n                                if (lastAssignmentBlock.EndIndex == aIndex - 1\r\n                                    && lastAssignmentBlock.ClassroomIndex == cIndex)\r\n                                {\r\n                                    // if block is continous, continue\r\n                                    lastAssignmentBlock.EndIndex = aIndex;\r\n                                    memory.Days[dIndex].AssignmentBlocks[lastBlockIndex] = lastAssignmentBlock;\r\n                                }\r\n                                else\r\n                                {\r\n                                    // start new block\r\n                                    memory.Days[dIndex].AssignmentBlocks.Add(new PersonAssignmentBlock()\r\n                                    {\r\n                                        ClassroomIndex = cIndex,\r\n                                        StartIndex = aIndex,\r\n                                        EndIndex = aIndex\r\n                                    });\r\n                                }\r\n                                memory.Days[dIndex].TotalAssignments++;\r\n                            }\r\n                        }\r\n\r\n                        if (assignment.HasValuesSet())\r\n                        {\r\n                            WorkForPerson(assignment.SupervisorId);\r\n                            WorkForPerson(assignment.ReviewerId);\r\n                            WorkForPerson(assignment.ChairPersonId);\r\n                            _daysMemory[dIndex].TotalAssignmentsFilled++;\r\n                            _daysMemory[dIndex].FirstAssignment ??= aIndex;\r\n                            _daysMemory[dIndex].LastAssignment = aIndex;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public float CalculateScore()\r\n        {\r\n            var sum = 0f;\r\n\r\n            for(var _i = 0; _i <= byte.MaxValue; _i++)\r\n            {\r\n                var person = _peopleMemory[_i];\r\n                if (!person.Exists)\r\n                    continue;\r\n\r\n                for (var dayIndex = 0; dayIndex < person.Days.Length; dayIndex++)\r\n                {\r\n                    var day = person.Days[dayIndex];\r\n\r\n                    // if no assignments in this day, ignore\r\n                    if (day.FirstAssignment == null || day.LastAssignment == null)\r\n                    {\r\n                        // prize for empty day multiplied by slot count\r\n                        sum += 1.0f; // * _solution.Days[dayIndex].SlotCount;\r\n                        continue;\r\n                    }\r\n\r\n                    // penaly for evening starting\r\n                    sum -= day.FirstAssignment.Value;\r\n\r\n                    var assignmentSpread = day.LastAssignment.Value - day.FirstAssignment.Value;\r\n                    var assignmentsTotal = day.TotalAssignments;\r\n                    // min(min(0, x-a), min(0, b-x)), b > a\r\n                    // penalty for having assignments away from a perfect range\r\n                    // having one assignment in a day makes no sense\r\n                    // having too many is overworking\r\n                    sum += Math.Min(\r\n                            Math.Min(0, assignmentsTotal - MinPerfectAssignmentsPerDayCount),\r\n                            Math.Min(0, MaxPerfectAssignmentsPerDayCount - assignmentsTotal)\r\n                            );\r\n\r\n                    // starting early with one assignment, and finishing with another very late makes no sense\r\n                    // limit how far those may be by giving negative points for the value being too big\r\n                    sum += Math.Min(0, AcceptableMaxAssignmentSpreadPerDay - assignmentSpread);\r\n\r\n                    for (int i = 0; i < day.AssignmentBlocks.Count; i++)\r\n                    {\r\n                        var assignmentBlock = day.AssignmentBlocks[i];\r\n                        var assignmentsInBlock = assignmentBlock.EndIndex - assignmentBlock.StartIndex + 1;\r\n                        // penalty for block being too large\r\n                        sum += Math.Min(0, AcceptableMaxAssignmentsInBlockPerDay - assignmentsInBlock);\r\n\r\n                        if (i < day.AssignmentBlocks.Count - 1)\r\n                        {\r\n                            // penalty for switching classes right between two assignments\r\n                            var block2 = day.AssignmentBlocks[i + 1];\r\n                            if (assignmentBlock.ClassroomIndex != block2.ClassroomIndex\r\n                                && assignmentBlock.EndIndex + 1 == block2.StartIndex)\r\n                            {\r\n                                sum += -1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return sum;\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimizer.Logic/Work/Heuristics/GeneralPeopleHeuristic.cs b/Optimizer.Logic/Work/Heuristics/GeneralPeopleHeuristic.cs
--- a/Optimizer.Logic/Work/Heuristics/GeneralPeopleHeuristic.cs	(revision a4ce34b4925a0fbf158bdbec29204d1b13c7c5d5)
+++ b/Optimizer.Logic/Work/Heuristics/GeneralPeopleHeuristic.cs	(date 1704986284925)
@@ -182,7 +182,7 @@
                     // having one assignment in a day makes no sense
                     // having too many is overworking
                     sum += Math.Min(
-                            Math.Min(0, assignmentsTotal - MinPerfectAssignmentsPerDayCount),
+                            Math.Min(0, 0),
                             Math.Min(0, MaxPerfectAssignmentsPerDayCount - assignmentsTotal)
                             );
 
Index: Optimizer.Runner/Program.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Globalization;\r\nusing System.Text;\r\nusing CsvHelper;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Logging.Console;\r\nusing Optimizer.Logic;\r\n\r\nusing var reader = new StreamReader(Path.Combine(\"Examples\", \"assignments.csv\"));\r\nusing var reader2 = new StreamReader(Path.Combine(\"Examples\", \"chairpersons.csv\"));\r\nusing var csv1 = new CsvReader(reader, CultureInfo.InvariantCulture);\r\nusing var csv2 = new CsvReader(reader2, CultureInfo.InvariantCulture);\r\nvar records1 = csv1.GetRecords<Assignments>();\r\nvar records2 = csv2.GetRecords<ChairPerson>();\r\n\r\n\r\nusing var loggerFactory = LoggerFactory.Create(builder =>\r\n{\r\n    builder.AddSimpleConsole(options =>\r\n    {\r\n        options.ColorBehavior = LoggerColorBehavior.Enabled;\r\n        options.IncludeScopes = false;\r\n        options.SingleLine = false;\r\n        options.TimestampFormat = \"HH:mm:ss.fff \";\r\n\r\n    });\r\n    builder.SetMinimumLevel(LogLevel.Trace);\r\n});\r\nvar logger = loggerFactory.CreateLogger<Program>();\r\n\r\nvar root = new Root(loggerFactory);\r\n\r\n\r\nInput input = new Input()\r\n{\r\n    ChairPersonIds = records2.Select(row => row.ChairPersonId).ToArray(),\r\n    Combinations = records1\r\n        .GroupBy(assignments => (assignments.ReviewerId, assignments.SupervisorId),\r\n            (key, enumerable) => new InputCombination()\r\n            {\r\n                ReviewerId = key.ReviewerId,\r\n                PromoterId = key.SupervisorId,\r\n                TotalCount = enumerable.Count()\r\n            }).ToArray(),\r\n    Days = new[]\r\n    {\r\n        new InputDay()\r\n        {\r\n            Id = 1,\r\n            Classrooms = new[]\r\n            {\r\n                new InputClassroom() { RoomId = 1 },\r\n                new InputClassroom() { RoomId = 2 }\r\n            },\r\n            SlotCount = 18\r\n        },\r\n        new InputDay()\r\n        {\r\n            Id = 2,\r\n            Classrooms = new[]\r\n            {\r\n                new InputClassroom() { RoomId = 1 },\r\n                new InputClassroom() { RoomId = 2 }\r\n            },\r\n            SlotCount = 18\r\n        },\r\n    },\r\n    ForbiddenSlots = Array.Empty<(int, int, int)>()\r\n};\r\n\r\nvar ct = new CancellationTokenSource();\r\n\r\nvar state = root.Optimize(input, ct.Token, OptimizerType.Simple);\r\n\r\n\r\nvar operationsLimit = 10000000;\r\nvar timeLimit = TimeSpan.FromMinutes(60);\r\n\r\n\r\nvar timeStart = DateTime.Now;\r\n\r\n\r\nlogger.LogInformation($\"Start: operationsLimit: {operationsLimit}, timeLimit: {timeLimit}\");\r\n\r\nvoid LogInfo()\r\n{\r\n    logger.LogInformation($\"Operations: {state.OperationsDone:D10}, evaluations: {state.Evaluations}, dead-ends: {state.DeadEnds}, partial score: {state.PartialScore}, best complete score:{state.Result?.Score:F5}, depth: {state.CurrentDepth} ({(100f * state.CurrentDepth /(float) state.MaxDepth):F}%, level: {(100 * state.CurrentDepthCompleteness):F}%), pds: {state.PercentDomainSeen:F5}%\");\r\n\r\n}\r\n\r\nbool ShouldStopDueToTimeLimit()\r\n{\r\n    if (DateTime.Now > timeStart.Add(timeLimit))\r\n    {\r\n        logger?.LogInformation(\"Timeout, cancelling...\");\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nConsole.CancelKeyPress += (sender, eventArgs) =>\r\n{\r\n    Finish();\r\n};\r\n\r\nwhile (state.IsWorking && !ShouldStopDueToTimeLimit())\r\n{\r\n    LogInfo();\r\n    await Task.Delay(TimeSpan.FromSeconds(1));\r\n}\r\n\r\nawait Finish();\r\n\r\nasync Task Finish()\r\n{\r\n    ct.Cancel();\r\n\r\n    LogInfo();\r\n    logger.LogInformation($\"DONE! time: {DateTime.Now.Subtract(timeStart).TotalSeconds}\");\r\n\r\n    if (state.Task?.Exception != null)\r\n        logger.LogError(state.Task?.Exception, \"Optimize error\");\r\n\r\n\r\n    if (state.Result.HasValue)\r\n    {\r\n        var sb = new StringBuilder();\r\n        foreach (var day in state.Result.Value.Days)\r\n        {\r\n            sb.AppendLine($\"=== Day {day.DayId} ===\");\r\n            foreach (var classroom in day.Classrooms)\r\n            {\r\n                sb.AppendLine($\"== Classroom {classroom.RoomId} ==\");\r\n                foreach (var assignment in classroom.Assignments)\r\n                    if (assignment != null)\r\n                    {\r\n                        sb.AppendLine(assignment.ToString());\r\n                    }\r\n                    else\r\n                    {\r\n                        sb.AppendLine(\"Nothing!\");\r\n                    }\r\n            }\r\n\r\n            sb.AppendLine(\"\");\r\n        }\r\n\r\n        var res = sb.ToString();\r\n        logger.LogInformation(res);\r\n\r\n        await using var writer = new StreamWriter(\"result.txt\");\r\n        await writer.WriteAsync(res); //JsonSerializer.Serialize(state.Result.Value)\r\n        logger.LogInformation(\"Result saved: {Path}\", Path.Join(Directory.GetCurrentDirectory(), \"result.json\"));\r\n\r\n        //await using var writerCsv = new StreamWriter(\"result.json\");\r\n        //state.Result.Value.Days.Select(d => d.Classrooms.Select(c => c.Assignments.Select(a => (a.Value.ReviewerId, a.Value.SupervisorId, a.Value.ChairPersonId)))).ToList();\r\n        /*\r\n        var records = new List<CsvRow>\r\n        {\r\n            new() { DayId = 0, ClassroomId= 0, ChairPersonId=0, ReviewerId=0, SupervisorId=0 },\r\n        };\r\n    \r\n        using (var writerCsv = new StreamWriter(Path.Join(Directory.GetCurrentDirectory(), \"result.csv\")))\r\n        using (var csv = new CsvWriter(writerCsv, CultureInfo.InvariantCulture))\r\n        {\r\n            csv.WriteRecords(records);\r\n        }\r\n        */\r\n    }\r\n}\r\n\r\ndelegate bool EventHandler(CtrlType sig);\r\n\r\nenum CtrlType\r\n{\r\n    CTRL_C_EVENT = 0,\r\n    CTRL_BREAK_EVENT = 1,\r\n    CTRL_CLOSE_EVENT = 2,\r\n    CTRL_LOGOFF_EVENT = 5,\r\n    CTRL_SHUTDOWN_EVENT = 6\r\n}\r\n\r\n\r\npublic class CsvRow\r\n{\r\n    public int DayId{ get; set; }\r\n    public int ClassroomId{ get; set; }\r\n    public int? ChairPersonId { get; set; }\r\n    public int? SupervisorId { get; set; }\r\n    public int? ReviewerId { get; set; }\r\n}\r\n\r\npublic class Assignments\r\n{\r\n    public int SupervisorId { get; set; }\r\n    public int ReviewerId { get; set; }\r\n}\r\n\r\npublic class ChairPerson\r\n{\r\n    public int ChairPersonId { get; set; }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimizer.Runner/Program.cs b/Optimizer.Runner/Program.cs
--- a/Optimizer.Runner/Program.cs	(revision a4ce34b4925a0fbf158bdbec29204d1b13c7c5d5)
+++ b/Optimizer.Runner/Program.cs	(date 1704921270478)
@@ -73,7 +73,7 @@
 
 
 var operationsLimit = 10000000;
-var timeLimit = TimeSpan.FromMinutes(60);
+var timeLimit = TimeSpan.FromMinutes(1);
 
 
 var timeStart = DateTime.Now;
